# Masked Bitmatrix Density

## 问题描述

给定一个 `N×N` 的二进制位矩阵 `M`（保证`N`是64的整数倍，按行连续存储，每行使用 `N/64` 个 `uint64_t` 存储），和一个 `N` 位的掩码向量 `mask`（用 `uint64_t` 数组存储，长度为 `N/64`）。

定义第 `i` 行为**有效行**，当且仅当 `((mask[i / 64] >> (i % 64)) & 1) == 1`，即 `mask` 数组的第 `i` bit 为1。
对矩阵的每一列 `j`，统计**所有有效行**中，该列 `1` 的个数，输出所有列的统计值。

**目标**：在保证正确性的情况下，最大化你的运算速度，充分利用位运算知识，必要时考虑使用向量化指令优化。

## 输入输出

- **输入**：
  - `int N`（矩阵维度，`512 <= N <= 8192, N % 64 == 0`）
  - `const uint64_t* matrix`（按行存储的位矩阵，长度 `N * N / 64`）
  - `const uint64_t* mask`（长度 `N/64` ）
- **输出**：
  - `uint32_t* result`（长度 `N`，存储每列的统计值，**保证每次调用前已全部零初始化**）

## 接口定义

为了简化流程，在这道题中你不需要考虑任何数据解析、程序框架等其余内容，仅需实现 `source_code/user.cpp` 中的以下函数，各参数定义详解上文。

为了减小波动，你的函数可能会被主程序调用多次，以**平均耗时**计算成绩，但每次调用时传入的参数**不一定**一样。

特别地，你的程序仅会被分配**一个CPU核心**
```cpp
void masked_bitmatrix_density(
	int             N,
	const uint64_t* matrix,
	const uint64_t* mask,
	uint32_t*       result) {
	// YOUR CODE HERE
}
```

**请不要修改其它文件，除去 `source_code/user.cpp` 与 `writeup.md` 外的任何文件均不会被上传**

## 得分计算

本题有多个测试样例，每个样例的得分按以下规则计算：

若正确性校验不通过或用时超过 $t_{max}$ 则为0分，若用时小于 $t_{min}$ 则为满分，否则按以下方式插值赋分
$$
\text{score\_ratio} = \sqrt\frac{t_{min}}{t}\cdot\frac{t_{max} - t}{t_{max} - t_{min}}
$$
其中 $t$ 为你该算例的平均用时，$\text{score\_ratio}$ 为你该算例得分百分比，你的总得分为所有样例得分之和。

你可以使用 `python evaluate.py` 来测试你的代码并查看得分，其中编译选项为 `clang++ -std=c++20 -O3 main.cpp user.cpp`

### 测试点信息

| 编号 | 分值占比 | `N`  | $t_{min}$ | $t_{max}$ |
| ---- | -------- | ---- | --------- | --------- |
| 1    | 20%      | 512  | 9.5 μs    | 237.5 μs  |
| 2    | 20%      | 1024 | 32 μs     | 800 μs    |
| 3    | 30%      | 2048 | 123 μs    | 3075 μs   |
| 4    | 30%      | 4096 | 495 μs    | 12375 μs  |

## 提示

可能用到的知识点：访存优化、位运算、一定的数学知识、向量化

简单的优化即可得到一定分数，但想要达到满分可能需要用上各种优化手段，不过精心挑选的得分计算方式将确保你每一步的优化都是物有所值的

在**进行完算法层面的优化**后，或许可以参考 [ARM Neon Intrinsics](https://github.com/rogerou/Arm-neon-intrinsics) 进一步优化，也可以在 [Compiler Explorer](https://godbolt.org/) 上查看编译器生成的汇编代码辅助你进行优化

不要试图钻空子——即使是小概率事件也可能会发生

运行编译前记得先 `module load bisheng/2.5.0` 以加载编译环境

你可以在 `source_code` 目录下使用 `make` 命令编译生成可执行文件 `bitmatrix` 进行测试，用法： `./bitmatrix <N> [rep = 1000] [seed = 42] [key = 0xDEADBEAF]`
